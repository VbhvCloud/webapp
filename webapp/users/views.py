# Python Imports
import base64
import logging

# Django imports
from django.contrib.auth import authenticate
from django.db import transaction

# Rest framework Imports
from rest_framework import status, generics
from rest_framework.authentication import BasicAuthentication
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView

# Project Imports
from .models import User
from .serializers import UserCreateSerializer, UserUpdateSerializer, LoginSerializer
from .utils import response

# To log the messages
logger = logging.getLogger(__name__)


class RegisterUser(generics.CreateAPIView):
    """
    Implements the API for registering a new user.
    No authentication is required to access this API.

    **POST**:
    Creates a new user in the database.

    **Returns**:
        `200`: Successful creation of user with the returned user information.
        `409`: If the email provided is already registered.
        `400`: If the data provided in the request is invalid.
        `408`: If a timeout error occurs.
    """
    authentication_classes = []
    permission_classes = []
    serializer_class = UserCreateSerializer

    def post(self, request, *args, **kwargs):
        try:
            if User.objects.filter(email=request.data.get("email")).exists():
                return response(False, "Email ID already Exists", status.HTTP_409_CONFLICT)
            user = self.get_serializer(data=request.data)
            if user.is_valid():
                with transaction.atomic():
                    user.save()
                return_data = User.objects.filter(email=request.data.get("email")) \
                    .values("id", "first_name", "last_name", "email", "account_created", "account_updated").first()
                return response(True, "User Created Successfully", status.HTTP_201_CREATED, return_data)
            return response(False, user.errors, status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return response(False, str(e), status.HTTP_408_REQUEST_TIMEOUT)


class Login(generics.GenericAPIView):
    """
    Login API view.
    This class implements the logic for user login.

    **Returns**:
        response with authentication token and user data.

    """

    serializer_class = LoginSerializer
    authentication_classes = []
    permission_classes = []

    @staticmethod
    def post(request, *args, **kwargs):
        try:
            # check if the request contains necessary data
            if not request.data.get("email", None) or not request.data.get("password", None):
                return response(False, "Please provide login credentials", status.HTTP_400_BAD_REQUEST)

            # authenticate the user using provided credentials
            user = authenticate(request, username=request.data.get("email"), password=request.data.get("password"))
            if user is not None:

                # get user details
                user_details = User.objects.get(email=user.get_username())

                # generate token
                token = base64.b64encode(
                    f'{request.data.get("email")}:{request.data.get("password")}'.encode()).decode()

                # return response with token and user data
                return response(True, "Login Successful", status.HTTP_200_OK, data={
                    "first_name": user_details.first_name,
                    "last_name": user_details.last_name,
                    "email": user_details.email
                }, headers={
                    "access-token": token
                })

            # return error if authentication fails
            return response(False, "Invalid Credentials", status.HTTP_401_UNAUTHORIZED)
        except Exception as e:
            return response(False, str(e), status.HTTP_408_REQUEST_TIMEOUT)


class Users(generics.GenericAPIView):
    """
    User API

    This API is used to get and update the details of the user.

    - To get the details of the user with need the basic token in header which can be generated by login API.
    - To update the details of the user with need the basic token in header which can be generated by login API.
    """

    serializer_class = UserUpdateSerializer
    authentication_classes = [BasicAuthentication]
    permission_classes = [IsAuthenticated]

    @staticmethod
    def get(request, *args, **kwargs):

        try:
            user_data = User.objects.filter(id=request.user.id).values("id", "first_name", "last_name", "email",
                                                                       "account_created", "account_updated")

            return response(True, "User data fetched successfully", status.HTTP_200_OK, data=user_data.first())
        except Exception as e:
            return response(False, str(e), status.HTTP_408_REQUEST_TIMEOUT)

    @staticmethod
    def put(request, *args, **kwargs):

        try:
            if not request.data:
                return response(False, "No data to update", status.HTTP_400_BAD_REQUEST)
            user = UserUpdateSerializer(request.user, data=request.data, partial=True)
            if user.is_valid(raise_exception=True):
                with transaction.atomic():
                    user.save()
                return_data = User.objects.filter(email=request.user.get_username()). \
                    values("id", "first_name", "last_name", "email", "account_created", "account_updated").first()
                return response(True, "User Updated Successfully", status.HTTP_200_OK, return_data)
        except Exception as e:
            return response(False, str(e), status.HTTP_400_BAD_REQUEST)


class Health(APIView):
    """
    Health check API

    This API is used to check the health of the server and returns a success message and 200 status code if the server is running.

    ---

    **GET** - `/health/`

    **Returns**:
        `HTTP 200`: Health check successful
    """
    authentication_classes = []
    permission_classes = []

    @staticmethod
    def get(request, *args, **kwargs):
        return response(True, "Health check successful", status.HTTP_200_OK)
